    // VS Studio 2010 RC 1, tested under Framework 4.0, 3.5
    using System;
    using System.Collections.Generic;
    using System.Windows.Forms;
    namespace SynchronizationTest_3
    {
        public partial class Form1 : Form
        {
            private readonly Dictionary<Control, Action<int>> ControlToAction = new Dictionary<Control, Action<int>>();
            
            // new code : keep a reference to the control the end-user clicked
            private Control ClickedControl;
            public Form1()
            {
                InitializeComponent();
            }
            private void Form1_Load(object sender, EventArgs e)
            {
                ControlToAction.Add(treeView1, (i => { treeView1.SelectedNode = treeView1.Nodes[i]; }));
                ControlToAction.Add(listView1, (i => { listView1.Items[i].Selected = true; }));
                ControlToAction.Add(comboBox1, (i => { comboBox1.SelectedIndex = i; }));
                // new code : screen out redundant calls generated by other controls 
                // being updated
                treeView1.AfterSelect += (obj, evt)
                =>
                {
                 if (treeView1 == ClickedControl) SynchronizeSelection(evt.Node.Index);
                };
                listView1.SelectedIndexChanged += (obj, evt)
                =>
                {
                  if (listView1.SelectedIndices.Count > 0 && listView1 == ClickedControl)
                  {
                      SynchronizeSelection(listView1.SelectedIndices[0]);
                  }
                };
                comboBox1.SelectedValueChanged += (obj, evt)
                =>
                {
                  if (comboBox1 == ClickedControl) SynchronizeSelection(comboBox1.SelectedIndex);
                };
                // new code here : all three controls share a common MouseDownHandler
                treeView1.MouseDown += SynchronizationMouseDown;
                listView1.MouseDown += SynchronizationMouseDown;
                comboBox1.MouseDown += SynchronizationMouseDown;
                // trigger the first synchronization
                ClickedControl = treeView1;
                SynchronizeSelection(0);
            }
            // get a reference to the control the end-user moused down on
            private void SynchronizationMouseDown(object sender, MouseEventArgs e)
            {
                ClickedControl = sender as Control;
            }
            // revised code using state of ClickedControl as a filter
            private void SynchronizeSelection(int i)
            {
                // we're done if the reference to the clicked control is null
                if (ClickedControl == null) return;
                foreach (Control theControl in ControlToAction.Keys)
                {
                    if (theControl == ClickedControl) continue;
                    // for debugging only
                    Console.WriteLine(theControl.Name + " synchronized");
                    ControlToAction[theControl](i);
                }
                // set the clicked control to null
                ClickedControl = null;
            }
        }
    }
